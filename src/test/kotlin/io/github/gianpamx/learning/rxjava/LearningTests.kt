/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.github.gianpamx.learning.rxjava

import io.reactivex.Observable
import io.reactivex.functions.BiFunction
import io.reactivex.schedulers.Schedulers
import io.reactivex.subjects.UnicastSubject
import org.junit.Test
import java.util.concurrent.ThreadLocalRandom
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeUnit.MILLISECONDS
import java.util.concurrent.TimeUnit.SECONDS
import kotlin.concurrent.thread


class LearningTests {
    @Test
    fun `Connectable Observable`() {
        val source = Observable
                .just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
                .publish()

        source
                .subscribe {
                    println("Observer 1: $it")
                }

        source
                .map { it.length }
                .subscribe {
                    println("Observer 2: $it")
                }

        source.connect()
    }

    @Test
    fun `Interval Observable`() {
        Observable.interval(1, SECONDS).subscribe {
            println("$it Mississippi")
        }

        Thread.sleep(5_000)
    }

    @Test
    fun `Interval Hot or Cold Observable?`() {
        val seconds = Observable.interval(1, SECONDS)

        seconds.subscribe {
            println("Observer 1: $it")
        }

        Thread.sleep(5_000)

        seconds.subscribe {
            println("Observer 2: $it")
        }

        Thread.sleep(5_000)
    }

    @Test
    fun `Hot Interval Observable`() {
        val seconds = Observable.interval(1, SECONDS).publish()

        seconds.subscribe {
            println("Observer 1: $it")
        }

        seconds.connect()

        Thread.sleep(5_000)

        seconds.subscribe {
            println("Observer 2: $it")
        }

        Thread.sleep(5_000)
    }

    @Test
    fun `Stateful Observable`() {
        var count = 5
        val source = Observable.range(1, count)

        source.subscribe { println("Observer 1: $it") }

        count = 10

        source.subscribe { println("Observer 2: $it") }
    }

    @Test
    fun `Defer Observable`() {
        var count = 5
        val source = Observable.defer { Observable.range(1, count) }

        source.subscribe { println("Observer 1: $it") }

        count = 10

        source.subscribe { println("Observer 2: $it") }
    }

    @Test(expected = ArithmeticException::class)
    fun `Tradicional Fashion Exceptions`() {

        Observable.just(1 / 0)
                .subscribe({ i -> println("RECEIVED: " + i!!) },
                        { e -> println("Error Captured: $e") })
    }

    @Test
    fun `From Callable Observable`() {

        Observable.fromCallable { 1 / 0 }
                .subscribe({ i -> println("RECEIVED: " + i!!) },
                        { e -> println("Error Captured: $e") })
    }

    @Test
    fun `Disposable`() {
        val seconds = Observable.interval(1, SECONDS)

        val disposable = seconds.subscribe {
            println("Received: $it")
        }

        Thread.sleep(5_000)

        disposable.dispose()

        Thread.sleep(5_000)
    }

    @Test
    fun `Handling Disposal`() {
        val observable = Observable.create<Int> { emitter ->
            thread {
                var i = 0
                while (!emitter.isDisposed) {
                    emitter.onNext(i++)
                    Thread.sleep(1)
                }
                if (emitter.isDisposed) {
                    println("Disposed")
                    return@thread
                }
                emitter.onComplete()
            }
        }

        val connectableObservable = observable
                .skip(100, MILLISECONDS)
                .filter { it % 10 == 0 }
                .take(200, MILLISECONDS)
                .publish()

        connectableObservable.subscribe { println("$it") }

        connectableObservable.count().subscribe { count -> println("Count: $count") }

        connectableObservable.connect()

        Thread.sleep(1_000)
    }

    @Test
    fun `Scan vs Reduce Operator`() {
        val observable = Observable
                .interval(1, MILLISECONDS)
                .take(10)
                .publish()

        observable
                .scan { acc: Long, next: Long -> acc + next }
                .subscribe { println("scan: $it") }

        observable
                .reduce { acc: Long, next: Long -> acc + next }
                .subscribe { println("reduce: $it") }

        observable.connect()
        Thread.sleep(11)
    }

    @Test
    fun `Ambiguous Observable`() {
        val source1 = Observable.interval(1, SECONDS)
                .take(2)
                .map { l -> l + 1 } // emit elapsed seconds
                .map { l -> "Source1: $l seconds" }

        val source2 = Observable.interval(300, TimeUnit.MILLISECONDS)
                .map { l -> (l + 1) * 300 } // emit elapsed milliseconds
                .map { l -> "Source2: $l milliseconds" }

        Observable.amb(listOf(source1, source2))
                .subscribe { i -> println("RECEIVED: $i") }


        Thread.sleep(5_000)
    }

    @Test
    fun `Group by length`() {
        Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
                .groupBy { it.length }
                .flatMapSingle {
                    it.toList()
                }
                .subscribe {
                    println(it)
                }
    }

    @Test
    fun `Ref Count`() {
        val seconds = Observable.interval(1, SECONDS)
//                .publish()
//                .refCount()
                .share()

        seconds.take(5).subscribe { println("Observer 1: $it") }

        Thread.sleep(3_000)

        seconds.take(2).subscribe { println("Observer 2: $it") }

        Thread.sleep(3_000)

        seconds.subscribe { println("Observer 2: $it") }

        Thread.sleep(3_000)
    }

    @Test
    fun `Release Buffer`() {
        val subject = UnicastSubject.create<String>()

        Observable.interval(300, MILLISECONDS)
                .map { l -> ((l + 1) * 300).toString() + " milliseconds" }
                .subscribe(subject)

        Thread.sleep(2_000)

        subject.subscribe { s -> println("Observer 1: $s") }

        Thread.sleep(2_000)
    }

    @Test
    fun `Error when subscribing more than once`() {
        val subject = UnicastSubject.create<String>()

        Observable.interval(300, MILLISECONDS)
                .map { l -> ((l + 1) * 300).toString() + " milliseconds" }
                .subscribe(subject)

        Thread.sleep(2_000)

        subject.subscribe { s -> println("Observer 1: $s") }
        subject.subscribe({ s -> println("Observer 2: $s") }, { println("Expected exception") })

        Thread.sleep(2_000)
    }

    @Test
    fun `More than one observer`() {
        val subject = UnicastSubject.create<String>()

        Observable.interval(300, MILLISECONDS)
                .map { l -> ((l + 1) * 300).toString() + " milliseconds" }
                .subscribe(subject)

        Thread.sleep(2_000)

        //multicast to support multiple Observers
        val multicast = subject.publish().autoConnect()

        //bring in first Observer
        multicast.subscribe { s -> println("Observer 1: $s") }
        Thread.sleep(2_000)

        //bring in second Observer
        multicast.subscribe { s -> println("Observer 2: $s") }
        Thread.sleep(1_000)
    }

    @Test
    fun `Concurrent Observables`() {
        val source1 = Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
                .subscribeOn(Schedulers.computation())
                .map { intenseCalculation(it) }

        val source2 = Observable.range(1, 6)
                .subscribeOn(Schedulers.computation())
                .map { intenseCalculation(it) }


        Observable.zip(source1, source2, BiFunction<String, Int, String> { s1, s2 -> "$s1 - $s2" })
                .blockingSubscribe { println(it) }
    }


    fun <T> intenseCalculation(value: T): T {
        Thread.sleep(ThreadLocalRandom.current().nextInt(3_000).toLong())
        return value
    }

    @Test
    fun `A thread for each observer`() {
        val lengths = Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
                .subscribeOn(Schedulers.computation())
                .map { intenseCalculation(it) }
                .map { it.length }

        lengths.subscribe { println("Received $it on thread ${Thread.currentThread().name}") }

        lengths.subscribe { println("Received $it on thread ${Thread.currentThread().name}") }

        Thread.sleep(10_000)
    }

    @Test
    fun `A thread for all observers`() {
        val lengths = Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
                .subscribeOn(Schedulers.computation())
                .map { intenseCalculation(it) }
                .map { it.length }
                .publish()
                .autoConnect(2)

        lengths.subscribe { println("Received $it on thread ${Thread.currentThread().name}") }

        lengths.subscribe { println("Received $it on thread ${Thread.currentThread().name}") }

        Thread.sleep(10_000)
    }
}
